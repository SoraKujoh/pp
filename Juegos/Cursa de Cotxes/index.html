<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cursa ‚Äî Versi√≥n final (polic√≠a sin disparos, posici√≥n forzada)</title>
<style>
  :root{
    --bg:#071018;
    --panel:rgba(255,255,255,0.04);
    --accent1:#60a5fa;
    --accent2:#ff6b6b;
    --ui:#e6eefc;
    --muted:#9fb0c8;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071018 0%, #0b1220 100%);font-family:Inter,system-ui,Arial;color:var(--ui);-webkit-font-smoothing:antialiased}
  .wrap{display:flex;align-items:center;justify-content:center;height:100vh;padding:18px;box-sizing:border-box}
  canvas{border-radius:12px;box-shadow:0 18px 60px rgba(2,6,12,0.7);max-width:98vw;height:auto;display:block;background:transparent}
  #hud{position:fixed;left:18px;top:18px;z-index:80;display:flex;gap:14px;align-items:center}
  .stat{
    background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.04);
    padding:10px 14px;border-radius:12px;display:flex;align-items:center;gap:10px;backdrop-filter:blur(6px)
  }
  .score{
    font-weight:800;font-size:18px;line-height:1;color:linear-gradient(90deg,var(--accent1),var(--accent2));
    display:flex;flex-direction:column;
  }
  .score .label{font-size:11px;color:var(--muted);font-weight:700;letter-spacing:0.6px}
  .score .value{font-size:20px;color:#fff}
  .lives{display:flex;flex-direction:column;align-items:flex-end}
  .lives .label{font-size:11px;color:var(--muted);font-weight:700;letter-spacing:0.6px}
  .wheels{display:flex;gap:6px}
  .wheel{font-size:20px;filter:drop-shadow(0 6px 18px rgba(0,0,0,0.6))}
  #controls{position:fixed;right:18px;top:18px;z-index:80;display:flex;gap:8px}
  button.ui-btn{background:linear-gradient(90deg,var(--accent1),#7dd3fc);border:none;color:#04263b;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:0 8px 20px rgba(96,165,250,0.12)}
  .hint{position:fixed;right:18px;top:72px;color:var(--muted);font-size:13px;z-index:80}
  .press-counter{position:fixed;left:18px;bottom:18px;color:var(--muted);font-size:13px;z-index:80}
  .press-rate{position:fixed;left:18px;bottom:44px;color:var(--muted);font-size:13px;z-index:80}
  .announce{position:fixed;left:50%;top:46%;transform:translate(-50%,-50%);z-index:85;color:#fff;font-size:40px;font-weight:900;text-shadow:0 12px 40px rgba(0,0,0,0.7);padding:12px 26px;border-radius:12px;pointer-events:none;display:none}
  .announce .fancy{background:linear-gradient(90deg,var(--accent1),var(--accent2));-webkit-background-clip:text;background-clip:text;color:transparent}
  .escape-text{position:fixed;left:50%;top:40%;transform:translate(-50%,-50%);z-index:86;font-weight:900;font-size:52px;letter-spacing:2px;color:#fff;text-shadow:0 12px 40px rgba(0,0,0,0.8);display:none;pointer-events:none}
  .escape-text .glow{background:linear-gradient(90deg,var(--accent1),var(--accent2));-webkit-background-clip:text;background-clip:text;color:transparent}
  .nitro-indicator{position:fixed;right:18px;bottom:18px;padding:8px 12px;border-radius:10px;background:linear-gradient(90deg,var(--accent2),#ffd166);color:#04263b;font-weight:800;z-index:80;display:none}
  .nitro-indicator.active{display:block;box-shadow:0 12px 40px rgba(255,107,107,0.08)}
  .heart-ui{position:fixed;right:18px;top:120px;color:#ff6b9a;font-weight:800;z-index:80;display:none}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:90;pointer-events:none}
  .panel{pointer-events:auto;background:rgba(0,0,0,0.6);padding:18px;border-radius:12px;text-align:center;color:#fff}
  .panel button{margin-top:10px}
  @media(max-width:720px){ .announce{font-size:28px} .escape-text{font-size:36px} .score .value{font-size:16px} }
</style>
</head>
<body>
<div class="wrap">
  <div id="hud">
    <div class="stat score" id="scoreStat">
      <div class="label">PUNTOS</div>
      <div class="value" id="score">0</div>
    </div>
    <div class="stat lives" id="livesStat">
      <div class="label">VIDAS</div>
      <div class="wheels" id="wheels"></div>
    </div>
  </div>

  <div id="controls">
    <button id="pauseBtn" class="ui-btn">Pausa</button>
    <button id="restartBtn" class="ui-btn">Reiniciar</button>
  </div>

  <div class="hint">Flechas ‚Üê ‚Üí para cambiar de carril. Pulsa ESPACIO intensamente en el evento.</div>
  <div class="press-rate" id="pressRate" style="display:none">Ritmo: 0 p/s</div>
  <div class="press-counter" id="pressCounter" style="display:none">Pulsaciones restantes: 30</div>
  <div id="announceText" class="announce"><span class="fancy">Police Coming</span></div>
  <div id="escapeText" class="escape-text"><span class="glow">ESCAPE!</span></div>
  <div id="nitroIndicator" class="nitro-indicator">NITRO</div>
  <div id="heartUI" class="heart-ui">Coraz√≥n listo ‚Äî +1 vida</div>

  <canvas id="game" width="820" height="1000"></canvas>

  <div class="overlay" id="overlay" style="display:none">
    <div class="panel" id="panel">
      <h2 id="panelTitle">Game Over</h2>
      <p id="panelText">Puntuaci√≥n: 0</p>
      <button id="panelRestart" class="ui-btn">Reiniciar</button>
    </div>
  </div>
</div>

<script>
/* ====== Estado y configuraci√≥n ====== */
const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score'), wheelsEl = document.getElementById('wheels');
const pauseBtn = document.getElementById('pauseBtn'), restartBtn = document.getElementById('restartBtn');
const overlay = document.getElementById('overlay'), panelTitle = document.getElementById('panelTitle'), panelText = document.getElementById('panelText'), panelRestart = document.getElementById('panelRestart');
const pressCounterEl = document.getElementById('pressCounter'), pressRateEl = document.getElementById('pressRate');
const announceEl = document.getElementById('announceText'), escapeEl = document.getElementById('escapeText'), nitroIndicator = document.getElementById('nitroIndicator');
const heartUI = document.getElementById('heartUI');

const W = canvas.width, H = canvas.height;
let running = true, paused = false;
let score = 0, lives = 3, startTime = Date.now();
let keys = {};

/* carretera y perspectiva */
const lanes = 3;
let baseRoadWidth = W * 0.72;
const roadCenterX = W/2;
const horizonY_default = H * 0.12;
let horizonY = horizonY_default;

/* jugador */
const player = {
  lane: 1,
  x: W/2 - 39,
  y: H - 170,
  baseW: 78, baseH: 96,
  tilt: 0, wheelRotation: 0, targetX: 0,
  initY: H - 170
};

/* part√≠culas y nitro */
let particles = [];
const maxParticles = 220;
let screenShake = 0;
let nitroActive = false;

/* obst√°culos */
const obstacleTypes = [
  {name:'compact', color:'#d9534f', baseW:64, baseH:48, baseVy:2.2},
  {name:'taxi', color:'#f0ad4e', baseW:56, baseH:44, baseVy:2.8},
  {name:'truck', color:'#6c757d', baseW:110, baseH:70, baseVy:1.6},
  {name:'sport', color:'#8e44ad', baseW:58, baseH:40, baseVy:3.2},
  {name:'suv', color:'#2ecc71', baseW:78, baseH:56, baseVy:2.0}
];
let obstacles = [];
let spawnTimer = 0, spawnInterval = 60;

/* corazones (coleccionables) */
let hearts = [];
const heartVy = 2.2;

/* evento escape */
let eventActive = false;
let eventPhase = null; // 'countdown'|'announce'|'bar'|'escapeAnim'
let countdownValue = 3, countdownTimer = 0;
let announceTimer = 0, announceDuration = 1.0;
let barProgress = 0, barMax = 1;

/* pulsaciones */
const requiredPressesBase = 30;
let eventCount = 0;
let requiredPressesCurrent = requiredPressesBase;
let barPressIncrement = 1 / requiredPressesCurrent;
const barDecayRate = 0.03;
let pressTimestamps = [];

/* boost nitro */
const eventBoostDuration = 0.9;
const eventBoostSpeed = 700;
let eventBoostRemaining = 0;

/* animaci√≥n escape */
let escapeAnimTimer = 0;
const escapeAnimDuration = 1.6;
const escapeReturnDuration = 0.6;

/* bloqueo spawn tras escape */
let postEscapeSpawnBlock = false;
let postEscapeBlockTimer = 0;
const postEscapeBlockDuration = 1.5;

/* umbrales progresivos: 200,500,700,1000... (alterna +300/+200) */
let nextTriggerScore = 200;
const triggerSteps = [300,200];
let triggerStepIndex = 0;
let savedSpawnInterval = spawnInterval;

/* polic√≠a (m√°s lento) */
let police = null;
/* mantenemos bullets array por compatibilidad pero polic√≠a no dispara */
let bullets = [];
const bulletSpeed = 420;
const bulletRadius = 6;
const policeShootInterval = 3.0;
const policeFirstShootDelay = 1.5;
const policeBaseSpeed = 180; // m√°s lento

/* corazones */
const heartSpawnDelayAfterEvent = 1.2;
let heartPending = false;
let heartPendingTimer = 0;
const maxLives = 5;

/* efectos visuales */
let muzzleFlashesArr = [];
let impactFlashAlpha = 0;
const impactFlashDecay = 3.5;

/* transici√≥n */
let transitionProgress = 0;
let transitionTarget = 0;
const transitionDuration = 900;
let transitionStartTime = 0;

let eventStartPerf = 0;
let lastTime = performance.now();

/* ====== Utilidades ====== */
function lerp(a,b,t){ return a + (b-a)*t; }
function easeInOut(t){ return t<0.5 ? 2*t*t : -1 + (4-2*t)*t; }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

function depthScale(y){
  const t = clamp((y - horizonY) / (H - horizonY), 0, 1);
  return 0.35 + t * 0.65;
}
function roadWidthAt(y){
  const topW = baseRoadWidth * 0.18;
  const bottomW = baseRoadWidth;
  const t = clamp((y - horizonY) / (H - horizonY), 0, 1);
  return topW + (bottomW - topW) * t;
}
function laneXAt(laneIndex, y, carWidth){
  const roadW = roadWidthAt(y);
  const left = roadCenterX - roadW/2 + 12;
  const laneW = (roadW - 24) / lanes;
  return left + laneIndex * laneW + (laneW - carWidth)/2;
}

/* ====== UI: score y vidas (ruedas) ====== */
function renderScore(){
  scoreEl.textContent = score;
}
function renderLives(){
  wheelsEl.innerHTML = '';
  for(let i=0;i<lives;i++){
    const span = document.createElement('span');
    span.className = 'wheel';
    span.textContent = 'üõû';
    wheelsEl.appendChild(span);
  }
  if(lives === 0){
    const span = document.createElement('span');
    span.style.color = '#ff6b6b';
    span.style.fontWeight = '800';
    span.textContent = '‚Äî';
    wheelsEl.appendChild(span);
  }
}

/* ====== Part√≠culas y nitro ====== */
function spawnParticle(x,y,dir,life,clr,vel){
  if(particles.length > maxParticles) particles.shift();
  particles.push({x,y,dx:(Math.random()*0.6-0.3)+(dir*vel),dy:-Math.random()*vel-0.6,life,age:0,clr,size:Math.random()*3+2});
}
function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.age += dt;
    p.x += p.dx * dt * 60;
    p.y += p.dy * dt * 60;
    p.dx *= 0.98;
    p.dy += 0.02 * dt * 60;
    if(p.age >= p.life) particles.splice(i,1);
  }
}
function drawParticles(){
  particles.forEach(p=>{
    const t = 1 - (p.age / p.life);
    ctx.globalAlpha = 0.9 * t;
    ctx.fillStyle = p.clr;
    ctx.beginPath();
    ctx.ellipse(p.x, p.y, p.size * t, p.size * 0.6 * t, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  });
}
function setNitro(on){
  nitroActive = on;
  if(on) nitroIndicator.classList.add('active'); else nitroIndicator.classList.remove('active');
}
function applyScreenShake(dt){
  if(screenShake > 0){
    const s = screenShake;
    const ox = (Math.random()*2 -1) * s;
    const oy = (Math.random()*2 -1) * s;
    canvas.style.transform = `translate(${ox}px, ${oy}px)`;
    screenShake = Math.max(0, screenShake - dt * 6);
  } else {
    canvas.style.transform = '';
  }
}

/* ====== Obst√°culos ====== */
function spawnObstacle(){
  const type = obstacleTypes[Math.floor(Math.random()*obstacleTypes.length)];
  const y = horizonY - (Math.random()*120 + type.baseH);
  const s = depthScale(y);
  const w = type.baseW * s;
  const laneIndex = Math.floor(Math.random()*lanes);
  const x = laneXAt(laneIndex, y, w);
  const vy = type.baseVy + Math.random()*1.6;
  obstacles.push({type, x, y, vy, laneIndex});
}

/* ====== Corazones ====== */
function spawnHeart(){
  const laneIndex = Math.floor(Math.random()*lanes);
  const y = horizonY - 80;
  const s = depthScale(y);
  const w = 36 * s;
  const x = laneXAt(laneIndex, y, w);
  hearts.push({lane: laneIndex, x, y, vy: heartVy});
  heartUI.style.display = 'none';
  heartPending = false;
}
function updateHearts(dt){
  for(let i=hearts.length-1;i>=0;i--){
    const h = hearts[i];
    h.y += h.vy * dt * 60;
    h.x = laneXAt(h.lane, h.y, 36 * depthScale(h.y));
    const sP = depthScale(player.y + player.baseH/2);
    const pW = player.baseW * sP, pH = player.baseH * sP;
    const pX = player.x, pY = player.y;
    const hw = 36 * depthScale(h.y);
    if(!(pX + pW < h.x || pX > h.x + hw || pY + pH < h.y || pY > h.y + hw)){
      hearts.splice(i,1);
      lives = Math.min(maxLives, lives + 1);
      renderLives();
      impactFlashAlpha = 0.35;
      screenShake = Math.max(screenShake, 6);
    } else if(h.y > H + 80){
      hearts.splice(i,1);
    }
  }
}
function drawHearts(){
  hearts.forEach(h=>{
    const s = depthScale(h.y);
    const w = 36 * s, hH = 32 * s;
    const x = h.x, y = h.y;
    ctx.save();
    ctx.translate(x + w/2, y + hH/2);
    ctx.rotate(Math.sin((performance.now()/300) + h.lane) * 0.12);
    ctx.translate(-(x + w/2), -(y + hH/2));
    const grad = ctx.createLinearGradient(x, y, x, y + hH);
    grad.addColorStop(0, '#ff6b9a'); grad.addColorStop(1, '#ff2d55');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(x + w*0.5, y + hH*0.85);
    ctx.bezierCurveTo(x + w*0.1, y + hH*0.6, x + w*0.05, y + hH*0.25, x + w*0.25, y + hH*0.18);
    ctx.bezierCurveTo(x + w*0.4, y + hH*0.12, x + w*0.5, y + hH*0.28, x + w*0.5, y + hH*0.45);
    ctx.bezierCurveTo(x + w*0.5, y + hH*0.28, x + w*0.6, y + hH*0.12, x + w*0.75, y + hH*0.18);
    ctx.bezierCurveTo(x + w*0.95, y + hH*0.25, x + w*0.9, y + hH*0.6, x + w*0.5, y + hH*0.85);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  });
}

/* ====== Balas y efectos de polic√≠a (DESACTIVADOS) ====== */
/* Polic√≠a ya no dispara: funciones vac√≠as o que limpian arrays residuales */
function spawnBullet(fromX, fromY, targetX, targetY){
  // Intencionalmente vac√≠o: la polic√≠a no dispara
}
function updateBullets(dt){
  // Aseguramos que no queden balas residuales
  if(bullets.length) bullets.length = 0;
}
function drawBullets(){
  // Sin balas, no dibujamos nada
}
function updateMuzzleFlashes(dt){
  // Limpiar efectos de fogonazo si existieran
  if(muzzleFlashesArr.length) muzzleFlashesArr.length = 0;
}

/* ====== Progresi√≥n de pulsaciones ====== */
function computeRequiredPresses(n){
  return requiredPressesBase + 5 * (n - 1);
}

/* ====== Evento: inicio y fin ====== */
function tryTriggerEvent(){
  if(eventActive) return;
  if(score >= nextTriggerScore){
    startEscapeEvent();
  }
}
function startEscapeEvent(){
  eventActive = true;
  eventPhase = 'countdown';
  countdownValue = 3; countdownTimer = 0;
  announceTimer = 0;
  barProgress = 0;
  eventBoostRemaining = 0;
  escapeAnimTimer = 0;

  eventCount++;
  requiredPressesCurrent = computeRequiredPresses(eventCount);
  barPressIncrement = 1 / requiredPressesCurrent;

  nextTriggerScore += triggerSteps[triggerStepIndex];
  triggerStepIndex = (triggerStepIndex + 1) % triggerSteps.length;

  savedSpawnInterval = spawnInterval;
  spawnInterval = Infinity;
  transitionTarget = 1;
  transitionStartTime = performance.now();
  police = {
    lane: player.lane,
    x: laneXAt(player.lane, player.y, player.baseW),
    y: player.y + 300,
    speed: policeBaseSpeed,
    color:'#2b6cff',
    delay: 0.6,
    delayTimer: 0,
    active: false,
    lightPhase: 0,
    shootTimer: 0
  };
  bullets = [];
  muzzleFlashesArr = [];
  pressTimestamps = [];
  pressCounterEl.style.display = 'block';
  pressRateEl.style.display = 'block';
  announceEl.classList.remove('show','hide');
  announceEl.style.display = 'none';
  escapeEl.style.display = 'none';
  updatePressCounter();
  updatePressRate(0);

  pressCounterEl.textContent = `Pulsaciones restantes: ${requiredPressesCurrent}`;
  eventStartPerf = performance.now();

  heartPending = true;
  heartPendingTimer = 0;
  heartUI.style.display = 'none';
}
function endEscapeEventFail(){
  transitionTarget = 0;
  transitionStartTime = performance.now();
  eventActive = false;
  eventPhase = null;
  police = null;
  bullets = [];
  muzzleFlashesArr = [];
  spawnInterval = Math.max(28, savedSpawnInterval - 6);
  pressCounterEl.style.display = 'none';
  pressRateEl.style.display = 'none';
  announceEl.classList.remove('show','hide');
  announceEl.style.display = 'none';
  escapeEl.style.display = 'none';
  setNitro(false);
  lives--; renderLives();
  if(lives <= 0){ running = false; showPanel('Game Over', `Puntuaci√≥n: ${score}`); }
}

/* ====== Transici√≥n ====== */
function updateTransition(now){
  if(transitionProgress === transitionTarget) return;
  const elapsed = now - transitionStartTime;
  const t = Math.min(1, elapsed / transitionDuration);
  const eased = easeInOut(t);
  transitionProgress = lerp(transitionProgress, transitionTarget, eased);
  horizonY = lerp(horizonY_default, H*0.5, transitionProgress);
}

/* ====== L√≥gica principal ====== */
function update(now){
  if(!running || paused) return;
  const dt = Math.min(0.05, (now - lastTime) / 1000);
  lastTime = now;
  updateTransition(now);

  updateParticles(dt);
  updateBullets(dt); // limpia cualquier bala
  updateMuzzleFlashes(dt);
  updateHearts(dt);

  if(impactFlashAlpha > 0){
    impactFlashAlpha = Math.max(0, impactFlashAlpha - dt * impactFlashDecay);
  }

  applyScreenShake(dt);

  if(heartPending){
    heartPendingTimer += dt;
    if(heartPendingTimer >= heartSpawnDelayAfterEvent){
      spawnHeart();
    } else {
      heartUI.style.display = 'block';
    }
  }

  if(!eventActive){
    if(keys['ArrowLeft']){ player.lane = Math.max(0, player.lane - 1); keys['ArrowLeft'] = false; }
    if(keys['ArrowRight']){ player.lane = Math.min(lanes-1, player.lane + 1); keys['ArrowRight'] = false; }
    player.targetX = laneXAt(player.lane, player.y, player.baseW);
    player.x += (player.targetX - player.x) * 0.22;
    const dx = player.targetX - player.x;
    player.tilt = dx * 0.02;
    player.wheelRotation += Math.sign(dx) * 0.18;
    player.wheelRotation *= 0.92;

    if(postEscapeSpawnBlock){
      postEscapeBlockTimer += dt;
      if(postEscapeBlockTimer >= postEscapeBlockDuration){
        postEscapeSpawnBlock = false;
      }
    } else {
      spawnTimer++;
      if(spawnTimer > spawnInterval){
        spawnTimer = 0;
        spawnObstacle();
        if(spawnInterval > 28) spawnInterval -= 0.35;
      }
    }

    const elapsedGame = (Date.now() - startTime) / 1000;
    const gameSpeed = 1.2 + elapsedGame * 0.045;
    for(let i = obstacles.length - 1; i >= 0; i--){
      const o = obstacles[i];
      const s = depthScale(o.y + o.type.baseH/2);
      o.y += (o.vy + gameSpeed) * (0.9 + s * 0.9) * dt * 60;
      o.x = laneXAt(o.laneIndex, o.y, o.type.baseW * s);
      if(o.y > H + 120){ obstacles.splice(i,1); score += 10; renderScore(); }
      else {
        const sO = depthScale(o.y + o.type.baseH/2);
        const oW = o.type.baseW * sO, oH = o.type.baseH * sO;
        const oX = o.x, oY = o.y;
        const pS = depthScale(player.y + player.baseH/2);
        const pW = player.baseW * pS, pH = player.baseH * pS;
        const pX = player.x, pY = player.y;
        const margin = Math.max(4, 6 * sO);
        if(!(pX + pW - margin < oX || pX + margin > oX + oW || pY + pH - margin < oY || pY + margin > oY + oH)){
          obstacles.splice(i,1);
          lives--; renderLives(); flashScreen();
          if(lives <= 0){ running = false; showPanel('Game Over', `Puntuaci√≥n: ${score}`); return; }
        }
      }
    }

    tryTriggerEvent();
    return;
  }

  /* evento activo */
  if(eventPhase === 'countdown'){
    countdownTimer += dt;
    if(countdownTimer >= 0.9){
      countdownTimer = 0;
      countdownValue--;
      if(countdownValue <= 0){
        eventPhase = 'announce';
        announceTimer = 0;
        announceEl.style.display = 'block';
        announceEl.classList.remove('hide'); announceEl.classList.add('show');
        if(police) police.lightPhase = 0;
      }
    }
    return;
  }

  if(eventPhase === 'announce'){
    announceTimer += dt;
    if(police) police.lightPhase += dt * 8;
    if(announceTimer >= announceDuration){
      announceEl.classList.remove('show'); announceEl.classList.add('hide');
      setTimeout(()=>{ announceEl.style.display = 'none'; announceEl.classList.remove('hide'); }, 360);
      eventPhase = 'bar';
      barProgress = 0;
      eventBoostRemaining = eventBoostDuration;
      if(police){ police.delayTimer = 0; police.active = false; police.shootTimer = 0; }
      pressCounterEl.textContent = `Pulsaciones restantes: ${requiredPressesCurrent}`;
    }
    return;
  }

  if(eventPhase === 'bar'){
    if(keys['ArrowLeft']){ player.lane = Math.max(0, player.lane - 1); keys['ArrowLeft'] = false; }
    if(keys['ArrowRight']){ player.lane = Math.min(lanes-1, player.lane + 1); keys['ArrowRight'] = false; }
    player.targetX = laneXAt(player.lane, player.y, player.baseW);
    player.x += (player.targetX - player.x) * 0.22;

    const nowMs = performance.now();
    const lastPress = pressTimestamps.length ? pressTimestamps[pressTimestamps.length-1] : 0;
    if(!lastPress || (nowMs - lastPress) > 300){
      barProgress -= barDecayRate * dt;
    }
    if(barProgress < 0) barProgress = 0;
    if(barProgress >= barMax){
      eventPhase = 'escapeAnim';
      escapeAnimTimer = 0;
      setNitro(true);
      escapeEl.style.display = 'block';
      pressCounterEl.style.display = 'none';
      pressRateEl.style.display = 'none';
      return;
    }

    const baseSlowFromProgress = 1 - Math.min(0.95, barProgress * 0.98);
    const slowFactor = Math.max(0.05, baseSlowFromProgress);
    const policeEffectiveSpeed = police ? police.speed * slowFactor : 0;

    let boostThisFrame = 0;
    if(eventBoostRemaining > 0){
      boostThisFrame = eventBoostSpeed * Math.min(eventBoostRemaining, dt);
      eventBoostRemaining = Math.max(0, eventBoostRemaining - dt);
      const px = player.x + player.baseW*0.5;
      const py = player.y + player.baseH*0.9;
      for(let i=0;i<8;i++){
        spawnParticle(px + (Math.random()*40-20), py + Math.random()*8, 0, 0.5 + Math.random()*0.4, `rgba(255,${120+Math.floor(Math.random()*80)},${20+Math.floor(Math.random()*120)},1)`, 2 + Math.random()*2);
      }
      screenShake = Math.max(screenShake, 6);
      setNitro(true);
    } else {
      setNitro(false);
    }

    const minAdvanceWhenProgress = 0.06;
    const effectiveFactor = Math.max(minAdvanceWhenProgress * Math.min(1, barProgress*2), Math.min(1, barProgress + 0.02));
    const advanceSpeed = policeEffectiveSpeed * effectiveFactor;

    player.y -= (advanceSpeed + boostThisFrame * 60) * dt;
    player.y = Math.max(horizonY + 6, player.y);

    if(police){
      if(!police.active){
        police.delayTimer += dt;
        if(police.delayTimer >= police.delay){
          police.active = true;
          police.shootTimer = 0;
        }
      } else {
        const dy = player.y - police.y;
        const desiredMove = police.speed * slowFactor * dt;
        const move = Math.sign(dy) * Math.min(Math.abs(dy), desiredMove);
        police.y += move;
        const targetPoliceX = laneXAt(player.lane, player.y, player.baseW);
        police.x += (targetPoliceX - police.x) * 0.08;
        if(police.y <= player.y + 40){
          endEscapeEventFail();
          return;
        }

        // Antes aqu√≠ se llamaba a spawnBullet; ahora la polic√≠a no dispara.
        // Mantenemos temporizadores para comportamiento visual (luces) pero no generamos proyectiles.
      }
      police.lightPhase += dt * 8;
    }

    if(nitroActive) player.wheelRotation += 0.9;
    else player.wheelRotation *= 0.92;

    updatePressCounter();
    return;
  }

  /* Animaci√≥n de escape: aceler√≥n y retorno forzado al final */
  if(eventPhase === 'escapeAnim'){
    escapeAnimTimer += dt;
    const t = escapeAnimTimer;

    if(t <= escapeAnimDuration){
      player.y -= 1000 * dt;
      screenShake = Math.max(screenShake, 7);
      const px = player.x + player.baseW*0.5;
      const py = player.y + player.baseH*0.9;
      for(let i=0;i<10;i++){
        spawnParticle(px + (Math.random()*44-22), py + Math.random()*10, 0, 0.5 + Math.random()*0.4, `rgba(255,${140+Math.floor(Math.random()*60)},${40+Math.floor(Math.random()*80)},1)`, 2.2 + Math.random()*2.4);
      }
    } else {
      const rt = clamp((t - escapeAnimDuration) / escapeReturnDuration, 0, 1);
      player.y = lerp(player.y, player.initY, easeInOut(rt));
      if(rt >= 1){
        // FIN: forzar restauraci√≥n completa del jugador y volver a juego normal
        setNitro(false);
        escapeEl.style.display = 'none';

        // Restaurar posici√≥n exacta e estado del jugador
        player.y = player.initY;
        player.lane = Math.max(0, Math.min(lanes - 1, player.lane));
        player.x = laneXAt(player.lane, player.initY, player.baseW);
        player.targetX = player.x;
        player.tilt = 0;
        player.wheelRotation = 0;

        // Forzar c√°mara y transici√≥n a estado inicial inmediatamente
        transitionTarget = 0;
        transitionStartTime = performance.now();
        transitionProgress = 0;
        horizonY = horizonY_default;

        // Restaurar estado del evento y del mundo
        eventActive = false; eventPhase = null;
        police = null;
        bullets = [];
        muzzleFlashesArr = [];
        spawnInterval = Math.max(28, savedSpawnInterval - 6);

        // Recompensa y bloqueo de spawn temporal
        score += 50; renderScore();
        postEscapeSpawnBlock = true;
        postEscapeBlockTimer = 0;

        // programar coraz√≥n para aparecer tras un peque√±o delay
        heartPending = true;
        heartPendingTimer = 0;
        heartUI.style.display = 'block';
      }
    }
    return;
  }
}

/* ====== Dibujo ====== */
function drawRoad(){
  if(eventActive && (eventPhase === 'bar' || eventPhase === 'escapeAnim')){
    const roadW = baseRoadWidth;
    const left = roadCenterX - roadW/2;
    ctx.fillStyle = '#071018'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#2b2f36'; ctx.fillRect(left, 0, roadW, H);
    ctx.strokeStyle = '#f7f7f7'; ctx.lineWidth = 4; ctx.setLineDash([28,22]);
    for(let i=1;i<lanes;i++){ const x = left + i * (roadW / lanes); ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(255,255,255,0.04)'; ctx.fillRect(left-10, 0, 8, H); ctx.fillRect(left + roadW + 2, 0, 8, H);

    if(nitroActive || eventPhase === 'escapeAnim'){
      ctx.save();
      ctx.globalAlpha = 0.14;
      ctx.strokeStyle = '#9fb8ff';
      ctx.lineWidth = 2;
      for(let i=0;i<20;i++){
        const yy = (i/20)*H + (performance.now()%600)/2;
        ctx.beginPath(); ctx.moveTo(left + 8, yy); ctx.lineTo(left + 8 + 140 + (i*8), yy - 46 - (i*2)); ctx.stroke();
      }
      ctx.restore();
    }
    return;
  }

  const pf = transitionProgress;
  const topW = baseRoadWidth * 0.18;
  const topWInterp = lerp(topW, baseRoadWidth, pf);
  const horizonInterp = lerp(horizonY_default, H*0.5, pf);

  ctx.fillStyle = '#071018'; ctx.fillRect(0,0,W,H);

  ctx.beginPath();
  ctx.moveTo(roadCenterX - topWInterp/2, horizonInterp);
  ctx.lineTo(roadCenterX + topWInterp/2, horizonInterp);
  ctx.lineTo(roadCenterX + baseRoadWidth/2, H);
  ctx.lineTo(roadCenterX - baseRoadWidth/2, H);
  ctx.closePath();
  ctx.fillStyle = '#2b2f36'; ctx.fill();

  ctx.strokeStyle = '#f7f7f7'; ctx.lineWidth = 4; ctx.setLineDash([28,22]);
  for(let i=1;i<lanes;i++){
    const t = i / lanes;
    const xBottom = roadCenterX - baseRoadWidth/2 + t * baseRoadWidth;
    const xTop = roadCenterX - topW/2 + t * topW;
    const xTopInterp = lerp(xTop, xBottom, pf);
    ctx.beginPath(); ctx.moveTo(xBottom, H); ctx.lineTo(xTopInterp, horizonInterp); ctx.stroke();
  }
  ctx.setLineDash([]);

  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  for(let i=0;i<40;i++){
    const y = (i / 40) * H;
    const w = 6 + Math.sin(i*0.6)*3;
    ctx.fillRect(roadCenterX - baseRoadWidth/2 - 10, y, w, 2);
    ctx.fillRect(roadCenterX + baseRoadWidth/2 + 4, y, w, 2);
  }
}

function drawObstacles(){
  obstacles.sort((a,b)=> a.y - b.y);
  obstacles.forEach(o=>{
    const s = depthScale(o.y + o.type.baseH/2);
    const w = o.type.baseW * s, h = o.type.baseH * s;
    const x = laneXAt(o.laneIndex, o.y, w), y = o.y;
    if(eventActive) ctx.globalAlpha = 0.45;
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.beginPath(); ctx.ellipse(x + w/2, y + h + 6*s, w*0.9, 12*s, 0, 0, Math.PI*2); ctx.fill();
    if(s > 0.55){
      ctx.fillStyle = o.type.color; roundRect(ctx, x, y, w, h, Math.max(6*s,4)); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.9)'; roundRect(ctx, x + w*0.18, y + h*0.18, w*0.64, h*0.34, Math.max(3*s,2)); ctx.fill();
      ctx.fillStyle = '#111'; ctx.beginPath(); ctx.ellipse(x + w*0.18, y + h*0.82, Math.max(5*s,4), Math.max(4*s,3), 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(x + w*0.82, y + h*0.82, Math.max(5*s,4), Math.max(4*s,3), 0, 0, Math.PI*2); ctx.fill();
    } else {
      ctx.save(); ctx.fillStyle = o.type.color; ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      const smallW = Math.max(12, w*0.6), smallH = Math.max(8, h*0.5);
      ctx.fillRect(x + (w-smallW)/2, y + (h-smallH)/2, smallW, smallH); ctx.strokeRect(x + (w-smallW)/2, y + (h-smallH)/2, smallW, smallH); ctx.restore();
    }
    if(eventActive) ctx.globalAlpha = 1.0;
  });
}

/* Dibujo del coche */
function drawPlayer(){
  const pf = transitionProgress;
  const sP = depthScale(player.y + player.baseH/2);
  const wP = player.baseW * sP, hP = player.baseH * sP;
  const xP = player.x, yP = player.y;
  const wT = player.baseW * 0.9, hT = player.baseH * 0.9;
  const xT = laneXAt(player.lane, player.y, wT);
  const yT = player.y;
  const w = lerp(wP, wT, pf);
  const h = lerp(hP, hT, pf);
  const x = lerp(xP, xT, pf);
  const y = lerp(yP, yT, pf);

  if(nitroActive || eventPhase === 'escapeAnim'){
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = '#9fb8ff';
    for(let i=0;i<6;i++){
      const sx = x + w/2 + (i-3)*6;
      const sy = y + h*0.6 + i*6;
      ctx.beginPath();
      ctx.ellipse(sx, sy + 10, w*0.9 + i*6, 18 + i*6, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  ctx.save();
  ctx.globalAlpha = lerp(1, 0.9, pf);
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.beginPath();
  ctx.ellipse(x + w/2, y + h + 8 * lerp(sP,1,pf), w * 1.05, 18 * lerp(sP,1,pf), 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  const grad = ctx.createLinearGradient(x, y, x, y + h);
  grad.addColorStop(0, '#ff6b6b'); grad.addColorStop(0.5, '#e53935'); grad.addColorStop(1, '#9b0f0f');
  ctx.save();
  const tiltAngle = player.tilt * 0.12 * (1 - pf);
  ctx.translate(x + w/2, y + h/2);
  ctx.rotate(tiltAngle);
  ctx.translate(-(x + w/2), -(y + h/2));
  roundRect(ctx, x, y, w, h, Math.max(6, 8 * (1 - pf) + 4 * pf));
  ctx.fillStyle = grad; ctx.fill();
  ctx.restore();

  const stripeW = Math.max(6, w * 0.08);
  ctx.fillStyle = '#0b0b0b';
  ctx.fillRect(x + w/2 - stripeW/2, y + h*0.06, stripeW, h*0.88);

  const winW = lerp(w * 0.46, w * 0.5, pf);
  const winH = lerp(h * 0.24, h * 0.18, pf);
  const winX = x + (w - winW) / 2;
  const winY = y + h * 0.18;
  ctx.fillStyle = '#fff';
  roundRect(ctx, winX, winY, winW, winH, Math.max(2, 3 * (1 - pf) + 2 * pf));
  ctx.fill();
  const cols = Math.max(3, Math.floor(winW / (8 * (1 - pf + 0.5*pf))));
  const rows = Math.max(2, Math.floor(winH / (8 * (1 - pf + 0.5*pf))));
  const cellW = winW / cols, cellH = winH / rows;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      ctx.fillStyle = ((r+c)%2===0) ? '#000' : '#fff';
      ctx.fillRect(winX + c*cellW, winY + r*cellH, cellW, cellH);
    }
  }
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.lineWidth = Math.max(1, 1.2 * (1 - pf) + 1 * pf);
  roundRect(ctx, winX, winY, winW, winH, Math.max(2, 3 * (1 - pf) + 2 * pf));
  ctx.stroke();

  const wheelR = Math.max(7, w * 0.11);
  const wheelYFront = y + h*0.78;
  const wheelYBack = y + h*0.92;
  drawWheelSimple(x + w*0.20, wheelYFront, wheelR, player.wheelRotation);
  drawWheelSimple(x + w*0.80, wheelYFront, wheelR, player.wheelRotation);
  drawWheelSimple(x + w*0.20, wheelYBack, wheelR*0.9, player.wheelRotation*0.9);
  drawWheelSimple(x + w*0.80, wheelYBack, wheelR*0.9, player.wheelRotation*0.9);

  if(nitroActive || eventPhase === 'escapeAnim'){
    const phase = performance.now() / 400;
    drawNitroEffect(x, y, w, h, phase);
  }
}
function drawWheelSimple(cx, cy, r, rot){
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rot);
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.ellipse(0, 0, r, r*0.8, 0, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#666';
  ctx.beginPath(); ctx.ellipse(0, 0, r*0.5, r*0.45, 0, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = Math.max(1, r*0.12);
  for(let i=0;i<6;i++){ ctx.beginPath(); ctx.moveTo(0,0); const a = (i/6) * Math.PI*2; ctx.lineTo(Math.cos(a)*r*0.5, Math.sin(a)*r*0.45); ctx.stroke(); }
  ctx.restore();
}
function drawNitroEffect(x,y,w,h,phase){
  const flameW = w * 0.36, flameH = h * 0.6;
  const fx = x + w*0.5 - flameW/2;
  const fy = y + h*0.6;
  const g = ctx.createLinearGradient(fx, fy, fx, fy + flameH);
  g.addColorStop(0, 'rgba(255,255,255,0.95)');
  g.addColorStop(0.15, 'rgba(255,220,120,0.95)');
  g.addColorStop(0.35, 'rgba(255,120,40,0.9)');
  g.addColorStop(1, 'rgba(200,40,200,0.06)');
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = g;
  ctx.beginPath();
  const jitter = Math.sin(phase*8) * 6;
  ctx.ellipse(fx + flameW/2 + jitter*0.2, fy + flameH/2, flameW * (1 + Math.abs(Math.sin(phase*6))*0.25), flameH * (0.9 + Math.abs(Math.cos(phase*5))*0.25), 0, 0, Math.PI*2);
  ctx.fill();
  for(let i=0;i<3;i++){
    ctx.globalAlpha = 0.12 * (1 - i*0.25);
    ctx.fillStyle = i===0 ? 'rgba(255,120,40,0.9)' : (i===1 ? 'rgba(255,60,160,0.12)' : 'rgba(60,140,255,0.08)');
    ctx.beginPath();
    ctx.ellipse(fx + flameW/2 + (i-1)*18 + Math.sin(phase*6+i)*6, fy + flameH*0.6 + i*12, flameW * (1.6 + i*0.6), flameH * (0.6 + i*0.6), 0, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalCompositeOperation = 'source-over';
}

/* UI del evento */
function drawEventUI(){
  if(!eventActive) return;
  ctx.save();
  if(eventPhase === 'countdown'){
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0, H*0.35, W, H*0.3);
    ctx.fillStyle = '#fff'; ctx.font = '120px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(String(countdownValue), W/2, H/2);
  }
  if(eventPhase === 'announce'){
    ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fillRect(0, H*0.35, W, H*0.3);
  }
  if(eventPhase === 'bar'){
    const barW = W * 0.6, barH = 28;
    const bx = (W - barW)/2, by = 40;
    ctx.fillStyle = 'rgba(255,255,255,0.12)'; roundRect(ctx, bx-4, by-4, barW+8, barH+8, 8); ctx.fill();
    ctx.fillStyle = '#0aef6a'; roundRect(ctx, bx, by, barW * (barProgress/barMax), barH, 6); ctx.fill();
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; roundRect(ctx, bx, by, barW, barH, 6); ctx.stroke();
    ctx.fillStyle = '#fff'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText(`Pulsa ESPACIO intensamente para rellenar la barra (${requiredPressesCurrent} pulsaciones)`, W/2, by + barH + 22);
    drawPolice();
  }
  ctx.restore();
}

/* dibujar polic√≠a */
function drawPolice(){
  if(!police) return;
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.beginPath(); ctx.ellipse(police.x + player.baseW/2, police.y + player.baseH + 6, player.baseW*0.9, 10, 0, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = police.color; roundRect(ctx, police.x, police.y, player.baseW*0.9, player.baseH*0.9, 6); ctx.fill();
  ctx.fillStyle = '#fff'; ctx.fillRect(police.x + player.baseW*0.12, police.y + player.baseH*0.18, player.baseW*0.76, player.baseH*0.18);

  const phase = (police.lightPhase || 0);
  const flash = Math.sin(phase) > 0 ? 1 : 0;
  const redAlpha = 0.6 * (flash ? 1 : 0.25);
  const blueAlpha = 0.6 * (flash ? 0.25 : 1);

  const lx = police.x + player.baseW*0.06, ly = police.y - 6, lw = player.baseW*0.28, lh = 10;
  ctx.fillStyle = `rgba(255,40,40,${redAlpha})`;
  roundRect(ctx, lx, ly, lw, lh, 4); ctx.fill();
  const rx = police.x + player.baseW*0.9 - player.baseW*0.28 - 2;
  ctx.fillStyle = `rgba(60,140,255,${blueAlpha})`;
  roundRect(ctx, rx, ly, lw, lh, 4); ctx.fill();

  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = `rgba(255,40,40,${0.06 * (flash ? 1.6 : 0.6)})`;
  ctx.beginPath();
  ctx.moveTo(lx + lw/2, ly + lh);
  ctx.lineTo(lx + lw/2 - 120, ly + lh + 220);
  ctx.lineTo(lx + lw/2 + 40, ly + lh + 220);
  ctx.closePath(); ctx.fill();

  ctx.fillStyle = `rgba(60,140,255,${0.06 * (flash ? 0.6 : 1.6)})`;
  ctx.beginPath();
  ctx.moveTo(rx + lw/2, ly + lh);
  ctx.lineTo(rx + lw/2 + 120, ly + lh + 220);
  ctx.lineTo(rx + lw/2 - 40, ly + lh + 220);
  ctx.closePath(); ctx.fill();
  ctx.globalCompositeOperation = 'source-over';

  ctx.restore();
}

/* ====== Panel y utilidades ====== */
function showPanel(title, text){ panelTitle.textContent = title; panelText.textContent = text; overlay.style.display = 'flex'; overlay.style.pointerEvents = 'auto'; }
function hidePanel(){ overlay.style.display = 'none'; overlay.style.pointerEvents = 'none'; }
function flashScreen(){ const prev = canvas.style.filter || ''; canvas.style.filter = 'brightness(1.6)'; setTimeout(()=> canvas.style.filter = prev, 120); }

/* ====== Contadores ====== */
function updatePressCounter(){
  const remaining = Math.max(0, Math.ceil((1 - barProgress) / barPressIncrement));
  pressCounterEl.textContent = `Pulsaciones restantes: ${remaining}`;
}
function updatePressRate(rate){
  pressRateEl.textContent = `Ritmo: ${rate} p/s`;
}

/* ====== Bucle principal ====== */
function loop(now){
  if(!running || paused) return;
  update(now);
  ctx.clearRect(0,0,W,H);
  drawRoad();
  drawObstacles();
  drawParticles();
  drawPlayer();
  drawBullets(); // no-op
  drawHearts();
  if(impactFlashAlpha > 0){
    ctx.save();
    ctx.globalAlpha = impactFlashAlpha;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }
  if(eventActive) drawEventUI();
  requestAnimationFrame(loop);
}

/* ====== Controles y reinicio ====== */
document.addEventListener('keydown', e=>{
  if(e.key === ' ' || e.code === 'Space'){
    if(eventActive && eventPhase === 'bar'){
      barProgress += barPressIncrement;
      if(barProgress > barMax) barProgress = barMax;
      const now = performance.now();
      pressTimestamps.push(now);
      while(pressTimestamps.length && (now - pressTimestamps[0]) > 1000) pressTimestamps.shift();
      updatePressCounter();
      updatePressRate(pressTimestamps.length);
    }
    e.preventDefault();
  }
  if(e.key === 'ArrowLeft' || e.key === 'ArrowRight') e.preventDefault();
  keys[e.key] = true;
});
document.addEventListener('keyup', e=> delete keys[e.key]);

pauseBtn.onclick = ()=> { paused = !paused; pauseBtn.textContent = paused ? 'Continuar' : 'Pausa'; if(!paused) loop(); };
restartBtn.onclick = resetGame;
panelRestart.onclick = resetGame;

function resetGame(){
  obstacles = []; spawnTimer = 0; spawnInterval = 60;
  score = 0; lives = 3; startTime = Date.now();
  renderScore(); renderLives();
  player.lane = 1; player.y = player.initY; player.x = laneXAt(player.lane, player.initY, player.baseW);
  player.targetX = player.x; player.tilt = 0; player.wheelRotation = 0;
  eventActive = false; eventPhase = null; police = null;
  transitionProgress = 0; transitionTarget = 0; horizonY = horizonY_default;
  pressTimestamps = [];
  pressCounterEl.style.display = 'none';
  pressRateEl.style.display = 'none';
  announceEl.style.display = 'none';
  escapeEl.style.display = 'none';
  eventBoostRemaining = 0;
  particles = [];
  bullets = [];
  muzzleFlashesArr = [];
  hearts = [];
  impactFlashAlpha = 0;
  setNitro(false);
  screenShake = 0;
  eventCount = 0;
  requiredPressesCurrent = requiredPressesBase;
  barPressIncrement = 1 / requiredPressesCurrent;
  nextTriggerScore = 200;
  triggerStepIndex = 0;
  postEscapeSpawnBlock = false;
  postEscapeBlockTimer = 0;
  heartPending = false;
  heartPendingTimer = 0;
  running = true; paused = false; hidePanel(); loop();
}

/* iniciar */
player.x = laneXAt(player.lane, player.y, player.baseW);
renderScore(); renderLives();
loop();

/* helper rounded rect */
function roundRect(ctx, x, y, w, h, r){ ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath(); }
</script>
</body>
</html>
